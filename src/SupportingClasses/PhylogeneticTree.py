"""
Created on June 3, 2019

@author: Daniel Konecki
"""
import os
import heapq
import numpy as np
from Bio.Phylo import read, write
from sklearn.cluster import AgglomerativeClustering
from Bio.Phylo.TreeConstruction import DistanceTreeConstructor


class PhylogeneticTree(object):
    """
    This class represents a phylogenetic tree as represented by the Bio.Phylo package. It allows for the construction of
    trees by several different methods, including loading a pre-existing tree.

    Attributes:
        __distance_matrix (Bio.Phylo.TreeConstruction.DistanceMatrix)
        tree_method (str): The method by which to construct a phylogenetic tree. The currently supported options are:
            'upgma'
            'agglomerative'
            'custom'
        tree_args (dict): The arguments needed to use each of these tree building methods.
            'upgma'
                No additional arguments.
            'agglomerative'
                'cache_dir' (str): The path to the directory where the agglomerative clustering data can be saved and
                loaded from.
                'affinity' (str): The affinity/distance calculation method to use when operating on the distance values
                for clustering. Further details can be found at: https://scikit-learn.org/stable/modules/generated/sklea
                rn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering. The options are:
                    euclidean (default)
                    l1
                    l2
                    manhattan
                    cosin
                    precomputed
                'linkage' (str): The linkage algorithm to use when building the agglomerative clustering tree structure.
                Further details can be found at: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.Agglo
                merativeClustering.html#sklearn.cluster.AgglomerativeClustering. The options are:
                    ward (default)
                    complete
                    average
                    single
            'custom'
                tree_path (str/path): The path to a file where the desired tree has been written in 'newick' format.
        tree (Bio.Phylo.Newick.Tree): The tree constructed using the specified method, until construct_tree has been
        called it is None.
    """

    def __init__(self, tree_building_method='upgma', tree_building_args={}):
        self.__distance_matrix = None
        self.tree_method = tree_building_method
        self.tree_args = tree_building_args
        self.tree = None

    def _custom_tree(self, tree_path):
        """
        Custom Tree

        This method loads a tree in the Newick format which should correspond to an alignment of interest.

        Args:
            tree_path (str): The full path to a Newick formatted tree which represents a target alignment.
        Returns:
            Bio.Phylo.Newick.Tree: Tree structure loaded from a file for a target alignment.
        """
        custom_tree = read(file=tree_path, format='newick')
        nodes_to_process = [custom_tree.root]
        while len(nodes_to_process) > 0:
            current_node = nodes_to_process.pop()
            if not current_node.is_terminal():
                nodes_to_process += current_node.clades
                current_node.name = 'Inner{}'.format(current_node.confidence)
                current_node.confidence = None
        return custom_tree

    def _upgma_tree(self):
        """
        UPGMA Tree

        This method generates a UPGMA tree.

        Returns:
            Bio.Phylo.Newick.Tree: Tree structure generated by the UPGMA method from the distance matrix computed for
            the target alignment.
        """
        constructor = DistanceTreeConstructor()
        upgma_tree = constructor.upgma(distance_matrix=self.__distance_matrix)
        return upgma_tree

    def _agglomerative_clustering(self, cache_dir=None, affinity='euclidean', linkage='ward'):
        """
        Agglomerative Clustering

        Constructs a tree using agglomerative/hierarchical clustering (this requires significant conversion from the
        formatted provided by sklearn).

        Args:
            cache_dir (str): The path to the directory where the agglomerative clustering data can be saved and loaded
            from.
            affinity (str): The affinity/distance calculation method to use when operating on the distance values for
            clustering. Further details can be found at: https://scikit-learn.org/stable/modules/generated/sklearn.clust
            er.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering. The options are:
                euclidean (default)
                l1
                l2
                manhattan
                cosin
                precomputed
            linkage (str): The linkage algorithm to use when building the agglomerative clustering tree structure.
            Further details can be found at: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.Agglomera
            tiveClustering.html#sklearn.cluster.AgglomerativeClustering. The options are:
                ward (default)
                complete
                average
                single
        Returns:
            Bio.Phylo.Newick.Tree: Tree structure generated by the agglomerative/hierarchical clustering method from the
            distance matrix computed for the target alignment.
        References:
            The solution for converting an agglomerative clustering tree from sklearn into a Newick formatted tree was
            taken from the following StackOverflow discussion, the solution used was provided by user: lucianopaz
            https://stackoverflow.com/questions/29127013/plot-dendrogram-using-sklearn-agglomerativeclustering
        """
        ml_model = AgglomerativeClustering(affinity=affinity, linkage=linkage, n_clusters=len(self.__distance_matrix),
                                           memory=cache_dir, compute_full_tree=True)
        ml_model.fit(np.array(self.__distance_matrix))
        newick_tree_string = convert_agglomerative_clustering_to_newick_tree(
            clusterer=ml_model, labels=self.__distance_matrix.names, distance_matrix=np.array(self.__distance_matrix))
        newick_fn = os.path.join(cache_dir, 'joblib', 'agg_clustering_{}_{}.newick'.format(affinity, linkage))
        with open(newick_fn, 'wb') as newick_handle:
            newick_handle.write(newick_tree_string)
        agg_clustering_tree = read(file=newick_fn, format='newick')
        return agg_clustering_tree

    def construct_tree(self, dm):
        """
        Construct Tree

        Construct the specified type of phylogenetic tree using the provided distance matrix.

        Args:
            dm (Bio.Phylo.TreeConstruction.DistanceMatrix): The distance matrix for an alignment of interest. If the
            tree building method is custom dm maybe be set to None. This method updates the __distance_matrix and tree
            attributes of the PhylogeneticTree instance.
        """
        method_dict = {'agglomerative': self._agglomerative_clustering, 'upgma': self._upgma_tree,
                       'custom': self._custom_tree}
        self.__distance_matrix = dm
        self.tree = method_dict[self.tree_method](**self.tree_args)

    def write_out_tree(self, filename):
        """
        Write Out Tree

        Writes the tree structure to file using the newick format.

        Args:
            filename (str): The full path to the file where the newick formatted tree should be written.
        """
        with open(filename, 'wb') as tree_handle:
            write(self.tree, file=tree_handle, format='newick')

    def traverse_top_down(self):
        """
        Traverse Base Tree

        This method generates a dictionary assigning sequences to clusters at each branching level (from 1 the root, to
        n the number of sequences) of the provided tree. This is useful for methods where a rooted Bio.Phylo.BaseTree
        object is used.

        Args:
            tree (Bio.Phylo.BaseTree): The tree to traverse and represent as a dictionary.
        Returns:
            dict: A nested dictionray where the first layer has keys corresponding to branching level and the second
            level has keys corresponding to specific branches within that level and the values are a list of the
            sequence identifiers in that branch.
        """

        def node_cmp(x, y):
            """
            Node Comparison

            This method is provided such that lists of nodes are sorted properly for the intended behavior of the UPGMA
            tree traversal.

            Args:
                x (Bio.Phylo.BaseTree.Clade): Left object in comparison.
                y (Bio.Phylo.BaseTree.Clade): Right object for comparison.
            Returns:
                int: Old comparator behavior, i.e. 1 x comes before y and -1 if y comes before x. If the two Clades are
                equal according to this comparison then 0 is returned.
            """
            if x.is_terminal() and not y.is_terminal():
                return -1
            elif not x.is_terminal() and y.is_terminal():
                return 1
            else:
                if x.total_branch_length() > y.total_branch_length():
                    return -1
                elif x.total_branch_length() < y.total_branch_length():
                    return 1
                else:
                    return 0

        # Traverse the tree
        # max_path_length = self.tree.root.total_branch_length()
        internal_nodes_to_process = []
        # leaf_nodes_to_process = []
        heapq.heappush(internal_nodes_to_process, (self.tree.root.branch_length, self.tree.root))
        while len(internal_nodes_to_process) > 0:
            print(internal_nodes_to_process)
            curr_branch_len, curr_node = heapq.heappop(internal_nodes_to_process)
            # if curr_node.is_terminal():
            print(curr_node.name, curr_branch_len)
            yield curr_node
            # else:
            for node in curr_node.clades: #  rsorted(curr_node.clades, cmp=node_cmp):
                # if node.is_terminal():
                #     path_length = max_path_length + curr_branch_len + node.branch_length
                #     heapq.heappush(internal_nodes_to_process, (path_length, node))
                # else:
                    # yield node
                heapq.heappush(internal_nodes_to_process, (curr_branch_len + node.branch_length, node))
            # for node in nodes_to_process:
            #     current_cluster.append(node)
            # current_cluster.sort(cmp=node_cmp)
            # print([(x.name, x.total_branch_length()) for x in current_cluster])
            # nearest_node = current_cluster.pop()
            # if not nearest_node.is_terminal():
            #     nodes_to_process = nearest_node.clades
            #     print([(x.name, x.total_branch_length()) for x in nodes_to_process])
            # else:
            #     nodes_to_process = []
            # yield nearest_node

    def traverse_bottom_up(self):
        """
        Traverse Base Tree

        This method generates a dictionary assigning sequences to clusters at each branching level (from 1 the root, to
        n the number of sequences) of the provided tree. This is useful for methods where a rooted Bio.Phylo.BaseTree
        object is used.

        Args:
            tree (Bio.Phylo.BaseTree): The tree to traverse and represent as a dictionary.
        Returns:
            dict: A nested dictionray where the first layer has keys corresponding to branching level and the second
            level has keys corresponding to specific branches within that level and the values are a list of the
            sequence identifiers in that branch.
        """

        def node_cmp(x, y):
            """
            Node Comparison

            This method is provided such that lists of nodes are sorted properly for the intended behavior of the UPGMA
            tree traversal.

            Args:
                x (Bio.Phylo.BaseTree.Clade): Left object in comparison.
                y (Bio.Phylo.BaseTree.Clade): Right object for comparison.
            Returns:
                int: Old comparator behavior, i.e. 1 x comes before y and -1 if y comes before x. If the two Clades are
                equal according to this comparison then 0 is returned.
            """
            if x.is_terminal() and not y.is_terminal():
                return 1
            elif not x.is_terminal() and y.is_terminal():
                return -1
            else:
                if x.total_branch_length > y.total_branch_length:
                    return -1
                elif x.total_branch_length < y.total_branch_length:
                    return 1
                else:
                    return 0

        def get_parent_and_path_length(node, tree):
            """
            Get Parent

            Get the parent of the passed in node.

            Args:
                node (Bio.Phylo.BaseTree.Clade): The node whose parent you would like to find.
                tree (Bio.Phylo.BaseTree): The tree to which the node belongs.
            Returns:
                 Bio.Phylo.BaseTree.Clade: The parent node of the passed in node, None is returned if the node provided
                 is the root.
            """
            if node == tree.root:
                parent = None
                length = 0
            else:
                node_path = tree.get_path(node)
                parent = node_path[-2]
                length = np.sum([x.branch_length for x in node_path])
            return parent, length

        # Traverse the tree
        nodes_to_process = [self.tree.root.get_terminals()]
        nodes_visited = set()
        for leaf in self.tree.root.get_terminals():
            _, dist = get_parent_and_path_length(leaf, self.tree)
            nodes_visited.add(leaf.name)
            heapq.heappush(nodes_to_process, (-1 * dist, leaf))
        while len(nodes_to_process) > 0:
            curr_node = heapq.heappop(nodes_to_process)
            nodes_visited.add(curr_node.name)
            yield curr_node
            parent_node, length = get_parent_and_path_length(curr_node, self.tree)
            if parent_node.name not in nodes_visited:
                nodes_visited.add(parent_node.name)
                parent_length = length - curr_node.branch_length
                heapq.heappush(nodes_to_process, (parent_length, parent_node))


def get_cluster_spanner(agg_clusterer):
    """
    Get Cluster Spanner

    Get a callable that computes a given cluster's span. To compute a cluster's span, call spanner(cluster). The cluster
    must be a 2D numpy array, where the axis=0 holds separate cluster members and the axis=1 holds the different
    variables.

    Args:
        agg_clusterer (sklearn.cluster.AgglomerativeClustering): Instance of the clustering model which has already been
        fit to data and which can be used to determine the proper way to extract distances from a given distance
        matrix.
    Returns:
        function: Callable to compute a given cluster's span.
    References:
        Taken from user lucianopaz's response on stackoverflow question:
        https://stackoverflow.com/questions/29127013/plot-dendrogram-using-sklearn-agglomerativeclustering
    """
    spanner = None
    if agg_clusterer.linkage == 'ward':
        if agg_clusterer.affinity == 'euclidean':
            spanner = lambda x: np.sum((x - agg_clusterer.pooling_func(x, axis=0)) ** 2)
    elif agg_clusterer.linkage == 'complete':
        if agg_clusterer.affinity == 'euclidean':
            spanner = lambda x: np.max(np.sum((x[:, None, :] - x[None, :, :]) ** 2, axis=2))
        elif agg_clusterer.affinity == 'l1' or agg_clusterer.affinity == 'manhattan':
            spanner = lambda x: np.max(np.sum(np.abs(x[:, None, :] - x[None, :, :]), axis=2))
        elif agg_clusterer.affinity == 'l2':
            spanner = lambda x: np.max(np.sqrt(np.sum((x[:, None, :] - x[None, :, :]) ** 2, axis=2)))
        elif agg_clusterer.affinity == 'cosine':
            spanner = lambda x: (np.max(np.sum((x[:, None, :] * x[None, :, :])) /
                                        (np.sqrt(np.sum(x[:, None, :] * x[:, None, :], axis=2, keepdims=True)) *
                                         np.sqrt(np.sum(x[None, :, :] * x[None, :, :], axis=2, keepdims=True)))))
        else:
            raise AttributeError('Unknown affinity attribute value {0}.'.format(agg_clusterer.affinity))
    elif agg_clusterer.linkage == 'average':
        if agg_clusterer.affinity == 'euclidean':
            spanner = lambda x: np.mean(np.sum((x[:, None, :] - x[None, :, :]) ** 2, axis=2))
        elif agg_clusterer.affinity == 'l1' or agg_clusterer.affinity == 'manhattan':
            spanner = lambda x: np.mean(np.sum(np.abs(x[:, None, :] - x[None, :, :]), axis=2))
        elif agg_clusterer.affinity == 'l2':
            spanner = lambda x: np.mean(np.sqrt(np.sum((x[:, None, :] - x[None, :, :]) ** 2, axis=2)))
        elif agg_clusterer.affinity == 'cosine':
            spanner = lambda x: (np.mean(np.sum((x[:, None, :] * x[None, :, :])) /
                                         (np.sqrt(np.sum(x[:, None, :] * x[:, None, :], axis=2, keepdims=True)) *
                                          np.sqrt(np.sum(x[None, :, :] * x[None, :, :], axis=2, keepdims=True)))))
        else:
            raise AttributeError('Unknown affinity attribute value {0}.'.format(agg_clusterer.affinity))
    else:
        raise AttributeError('Unknown linkage attribute value {0}.'.format(agg_clusterer.linkage))
    return spanner


def go_down_tree(children, n_leaves, x, leaf_labels, nodename, spanner, inner):
    """
    go_down_tree(children,n_leaves,X,leaf_labels,nodename,spanner)

    Iterative function that traverses the subtree that descends from
    nodename and returns the Newick representation of the subtree.

    Args:
        children (list): sklearn.cluster.AgglomerativeClustering.children_
        n_leaves (int): sklearn.cluster.AgglomerativeClustering.n_leaves_
        x (2D np.array): Parameters supplied to sklearn.cluster.AgglomerativeClustering.fit
        leaf_labels (list): The label for each parameter in array axis=0 of x.
        nodename (int): The intermediate node name whose children are located in children[nodename-n_leaves].
        spanner (function): Callable that computes the dendrite's span
    Returns:
        str: The str representation of the agglomerative clutering tree in Newick format.
    References:
        Taken from user lucianopaz's response on stackoverflow question:
        https://stackoverflow.com/questions/29127013/plot-dendrogram-using-sklearn-agglomerativeclustering
    """
    nodeindex = nodename-n_leaves
    if nodename < n_leaves:
        return leaf_labels[nodeindex], np.array([x[nodeindex]])
    else:
        node_children = children[nodeindex]
        branch1, branch1samples = go_down_tree(children, n_leaves, x, leaf_labels, node_children[1], spanner, inner)
        if branch1.endswith(')'):
            branch1 += 'Inner{}'.format(inner.pop())
        branch0, branch0samples = go_down_tree(children, n_leaves, x, leaf_labels, node_children[0], spanner, inner)
        if branch0.endswith(')'):
            branch0 += 'Inner{}'.format(inner.pop())
        node = np.vstack((branch0samples, branch1samples))
        branch0span = spanner(branch0samples)
        branch1span = spanner(branch1samples)
        nodespan = spanner(node)
        branch0distance = nodespan-branch0span
        branch1distance = nodespan-branch1span
        nodename = '({branch0}:{branch0distance},{branch1}:{branch1distance})'.format(
            branch0=branch0, branch0distance=branch0distance, branch1=branch1, branch1distance=branch1distance)
        return nodename, node


def build_newick_tree(children, n_leaves, x, leaf_labels, spanner):
    """
    Build Newcki Tree

    Generate a string representation (Newick tree) from the sklearn.cluster.AgglomerativeClustering.fit output.

    Args:
        children (list): sklearn.cluster.AgglomerativeClustering.children_
        n_leaves (int): sklearn.cluster.AgglomerativeClustering.n_leaves_
        x (2D np.array): Parameters supplied to sklearn.cluster.AgglomerativeClustering.fit
        leaf_labels (list): The label for each parameter in array axis=0 of x.
        spanner (function): Callable that computes the dendrite's span
    Returns:
        str: The final string with the Newick representation of the agglomerative clustering tree being converted.
    References:
        Taken from user lucianopaz's response on stackoverflow question:
        https://stackoverflow.com/questions/29127013/plot-dendrogram-using-sklearn-agglomerativeclustering
    """
    inner_labels = list(range(1, n_leaves))
    inner_string, inner_node = go_down_tree(children, n_leaves, x, leaf_labels, len(children)+n_leaves-1, spanner, inner_labels)
    prepend_to_root = inner_string + 'Inner{};'.format(inner_labels.pop())
    return prepend_to_root


def convert_agglomerative_clustering_to_newick_tree(clusterer, labels, distance_matrix):
    """
    Convert Agglomerative Clustering To Newick Tree

    This function converts the tree generated by sklearn.cluster.AgglomerativeClustering.fit() to a Newick formatted
    string.

    Args:
        clusterer (sklearn.cluster.AgglomerativeClustering): Instance of the clustering model which has already been
        fit to data and which can be used to determine the proper way to extract distances from a given distance
        matrix.
        labels (list): The label for each parameter in array axis=0 of distance_matrix.
        distance_matrix (2D np.array): Parameters supplied to sklearn.cluster.AgglomerativeClustering.fit
    Returns:
        str: The final string with the Newick representation of the agglomerative clustering tree being converted.
    References:
        Adapted from user lucianopaz's response on stackoverflow question:
        https://stackoverflow.com/questions/29127013/plot-dendrogram-using-sklearn-agglomerativeclustering
    """
    spanner = get_cluster_spanner(clusterer)
    # leaf_labels is a list of labels for each entry in X
    newick_tree = build_newick_tree(clusterer.children_, clusterer.n_leaves_, distance_matrix, labels, spanner)
    print(newick_tree)
    return newick_tree

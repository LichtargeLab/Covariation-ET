"""
Created on June 3, 2019

@author: Daniel Konecki
"""
import os
import heapq
import numpy as np
from time import time
from copy import deepcopy
from itertools import product
from Bio.Phylo import BaseTree
from sklearn.cluster import AgglomerativeClustering
from Bio.Phylo import read, write
from Bio.Phylo.TreeConstruction import DistanceMatrix
from Bio.Phylo.TreeConstruction import DistanceTreeConstructor


class PhylogeneticTree(object):
    """
    This class represents a phylogenetic tree as represented by the Bio.Phylo package. It allows for the construction of
    trees by several different methods, including loading a pre-existing tree.

    Attributes:
        distance_matrix (Bio.Phylo.TreeConstruction.DistanceMatrix) The distance matrix a tree is based on.
        tree_method (str): The method by which to construct a phylogenetic tree. The currently supported options are:
            'et'
            'upgma'
            'agglomerative'
            'custom'
        tree_args (dict): The arguments needed to use each of these tree building methods.
            'et'
                No additional arguments.
            'upgma'
                No additional arguments.
            'agglomerative'
                'cache_dir' (str): The path to the directory where the agglomerative clustering data can be saved and
                loaded from.
                'affinity' (str): The affinity/distance calculation method to use when operating on the distance values
                for clustering. Further details can be found at: https://scikit-learn.org/stable/modules/generated/sklea
                rn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering. The options are:
                    euclidean (default)
                    l1
                    l2
                    manhattan
                    cosin
                    precomputed
                'linkage' (str): The linkage algorithm to use when building the agglomerative clustering tree structure.
                Further details can be found at: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.Agglo
                merativeClustering.html#sklearn.cluster.AgglomerativeClustering. The options are:
                    ward (default)
                    complete
                    average
                    single
            'custom'
                tree_path (str/path): The path to a file where the desired tree has been written in 'newick' format.
        tree (Bio.Phylo.Newick.Tree): The tree constructed using the specified method, until construct_tree has been
        called it is None.
        size (int): The number of terminal nodes in the tree (size of the alignment used to calculate the distance
        matrix used for tree construction).
    """

    def __init__(self, tree_building_method='upgma', tree_building_args={}):
        self.distance_matrix = None
        self.tree_method = tree_building_method
        self.tree_args = tree_building_args
        self.tree = None
        self.size = None

    def _custom_tree(self, tree_path):
        """
        Custom Tree

        This method loads a tree in the Newick format which should correspond to an alignment of interest.

        Args:
            tree_path (str): The full path to a Newick formatted tree which represents a target alignment.
        Returns:
            Bio.Phylo.Newick.Tree: Tree structure loaded from a file for a target alignment.
        """
        custom_tree = read(file=tree_path, format='newick')
        nodes_to_process = [custom_tree.root]
        while len(nodes_to_process) > 0:
            current_node = nodes_to_process.pop()
            if not current_node.is_terminal():
                nodes_to_process += current_node.clades
                if current_node.confidence:
                    current_node.name = 'Inner{}'.format(current_node.confidence)
                    current_node.confidence = None
        return custom_tree

    def _upgma_tree(self):
        """
        UPGMA Tree

        This method generates a UPGMA tree.

        Returns:
            Bio.Phylo.Newick.Tree: Tree structure generated by the UPGMA method from the distance matrix computed for
            the target alignment.
        """
        def height_of(clade):
            """
            Height Of

            Calculate clade height -- the longest path to any terminal (PRIVATE).

            Copied verbatim from Bio.Phylo.DistanceTreeConstructor

            Args:
                clade (Bio.Phylo.BaseTree.Clade): Clade object for which to determine the height.
            Returns:
                int: The height of the provided clade.
            """
            height = 0
            if clade.is_terminal():
                height = clade.branch_length
            else:
                height = height + max(height_of(c) for c in clade.clades)
            return height

        if not isinstance(self.distance_matrix, DistanceMatrix):
            raise TypeError("Must provide a DistanceMatrix object.")
        dm = np.tril(np.array(self.distance_matrix))
        clades = [BaseTree.Clade(None, name) for name in self.distance_matrix.names]
        inner_count = 0
        while len(dm) > 1:
            min_dist = float(np.min(dm[np.tril_indices(dm.shape[0], k=-1)]))
            positions = np.where(dm == min_dist)
            lower_triangle_pos = positions[0] > positions[1]
            min_i = int(positions[0][lower_triangle_pos][-1])
            min_j = int(positions[1][lower_triangle_pos][-1])
            clade1 = clades[min_i]
            clade2 = clades[min_j]
            inner_count += 1
            inner_clade = BaseTree.Clade(None, "Inner" + str(inner_count))
            inner_clade.clades.append(clade1)
            inner_clade.clades.append(clade2)
            if clade1.is_terminal():
                clade1.branch_length = min_dist * 1.0 / 2
            else:
                clade1. branch_length = min_dist * 1.0 / 2 - height_of(clade1)
            if clade2.is_terminal():
                clade2.branch_length = min_dist * 1.0 / 2
            else:
                clade2. branch_length = min_dist * 1.0 / 2 - height_of(clade2)
            clades[min_j] = inner_clade
            del clades[min_i]
            new_dm = np.zeros((dm.shape[0] - 1, dm.shape[1] - 1))
            # Define full set of indices for new lower triangle
            new_lower_triangle_ind = np.tril_indices(new_dm.shape[0], k=-1)
            # Define the indices for the top of the new lower triangle (i.e. rows above first minimum row being joined)
            top_triangle_mask = new_lower_triangle_ind[0] < min_j
            top_triangle_ind = (new_lower_triangle_ind[0][top_triangle_mask],
                                new_lower_triangle_ind[1][top_triangle_mask])
            # Fill in the values from the top of the old dm, these positions do not change since they are above the
            # minimum values being merged)
            if len(top_triangle_ind[0]) > 0:
                new_dm[top_triangle_ind] = dm[top_triangle_ind]
            # Define the indices for the new row of the new lower triangle (i.e. the ones which will be filled in by
            # averaging the two minimum values rows)
            new_row_mask = new_lower_triangle_ind[0] == min_j
            new_row_ind = (new_lower_triangle_ind[0][new_row_mask], new_lower_triangle_ind[1][new_row_mask])
            # Compute the average of the two rows being merged and assign the result to the new row
            new_dm[new_row_ind] = np.mean(dm[[min_i, min_j], :][:, 0:min_j], axis=0)
            # Define the indices for the lower rectangle in the new lower triangle (i.e. positions between the minimum
            # row and column which will be filled by the averages from the merged rows/columns)
            lower_rectangle_mask = (new_lower_triangle_ind[0] > min_j) & (new_lower_triangle_ind[1] < min_j)
            lower_rectangle_ind = (new_lower_triangle_ind[0][lower_rectangle_mask],
                                   new_lower_triangle_ind[1][lower_rectangle_mask])
            # The lower rectangle in the old dm is bounded above by min_j (not inclusive), interrupted by min_i, and
            # bounded below by the end of the matrix. On the other axis it is bounded on the left by position 0 and on
            # the right by position min_i (not inclusive)
            new_dm[lower_rectangle_ind] = dm[np.r_[min_j + 1:min_i, min_i + 1:dm.shape[0]], :][: , 0:min_j].reshape(-1)
            # Define the indices for the new column of the new lower triangle (i.e. the columns which are merged from
            # the minimum values, to note, the end of the min_i row needs to be joined at the front of the min_i column)
            min_j_col = dm[np.r_[min_j + 1:min_i, min_i+1:dm.shape[0]], min_j].reshape(-1, 1)
            min_i_row = dm[min_i, :][min_j + 1: min_i].reshape(-1, 1)
            min_i_col = dm[min_i + 1:, min_i].reshape(-1, 1)
            min_i_col_final = np.vstack([min_i_row, min_i_col])
            to_average = np.hstack([min_j_col, min_i_col_final])
            new_col_mask = new_lower_triangle_ind[1] == min_j
            new_col_ind = (new_lower_triangle_ind[0][new_col_mask], new_lower_triangle_ind[1][new_col_mask])
            # Compute the average of the two columns being merged and assign the result to the new column
            new_dm[new_col_ind] = np.mean(to_average, axis=1)
            # Define the indices for the lower triangle of the new lower triangle (i.e. the triangle outside of the new
            # column being added)
            bottom_triangle_mask = (new_lower_triangle_ind[0] > min_j) & (new_lower_triangle_ind[1] > min_j)
            bottom_triangle_ind = (new_lower_triangle_ind[0][bottom_triangle_mask],
                                   new_lower_triangle_ind[1][bottom_triangle_mask])
            # The bottom triangle in the old dm is a subset of the bottom triangle form the original  dm bounded by the
            # min_j column on the left and excluding the min_i column and row.
            old_bottom_triangle_ind = np.tril_indices(dm.shape[0], k=-1)
            old_bottom_triangle_mask = (old_bottom_triangle_ind[0] > min_j) & (old_bottom_triangle_ind[0] != min_i) &\
                                       (old_bottom_triangle_ind[1] > min_j) & (old_bottom_triangle_ind[1] != min_i)
            old_bottom_triangle_ind = (old_bottom_triangle_ind[0][old_bottom_triangle_mask],
                                       old_bottom_triangle_ind[1][old_bottom_triangle_mask])
            if len(old_bottom_triangle_ind[0]):
                new_dm[bottom_triangle_ind] = dm[old_bottom_triangle_ind[0], old_bottom_triangle_ind[1]]
            dm = new_dm
        inner_clade.branch_length = 0
        return BaseTree.Tree(inner_clade)

    # def _et_tree(self):
    #     """
    #     ET Tree
    #
    #     This method reproduces the tree used by the Evolutionary Trace method in the past.This is a variant on the UPGMA
    #     tree construction method which joins nodes, not based on their minimum distance to each other but on the minimum
    #     average distance between their terminal descendants.
    #     """
    #
    #     def height_of(clade):
    #         """
    #         Height Of
    #
    #         Calculate clade height -- the longest path to any terminal (PRIVATE).
    #
    #         Copied verbatim from Bio.Phylo.DistanceTreeConstructor
    #
    #         Args:
    #             clade (Bio.Phylo.BaseTree.Clade): Clade object for which to determine the height.
    #         Returns:
    #             int: The height of the provided clade.
    #         """
    #         height = 0
    #         if clade.is_terminal():
    #             height = clade.branch_length
    #         else:
    #             height = height + max(height_of(c) for c in clade.clades)
    #         return height
    #
    #     original_dist_mat = np.array(self.distance_matrix)
    #     index_map = {}
    #     clades = []
    #     for i in range(self.size):
    #         name = self.distance_matrix.names[i]
    #         index_map[name] = i
    #         clade = BaseTree.Clade(None, name)
    #         clades.append(clade)
    #     inner_count = self.size
    #     dm = deepcopy(self.distance_matrix)
    #     inner_clade = None
    #     while len(dm) > 1:
    #         dm_array = np.array(dm)
    #         min_dist = float(np.min(dm_array[np.triu_indices(len(dm), k=1)]))
    #         positions = np.where(dm_array == min_dist)
    #         upper_triangle_pos = positions[1] > positions[0]
    #         min_i = int(positions[0][upper_triangle_pos][0])
    #         min_j = int(positions[1][upper_triangle_pos][0])
    #         clade1 = clades[min_i]
    #         clade2 = clades[min_j]
    #         inner_count -= 1
    #         inner_clade = BaseTree.Clade(None, "Inner{}".format(inner_count))
    #         inner_clade.clades.append(clade1)
    #         inner_clade.clades.append(clade2)
    #         # Assign branch length
    #         if clade1.is_terminal():
    #             clade1.branch_length = min_dist * 1.0 / 2
    #         else:
    #             clade1.branch_length = min_dist * 1.0 / 2 - height_of(clade1)
    #         if clade2.is_terminal():
    #             clade2.branch_length = min_dist * 1.0 / 2
    #         else:
    #             clade2.branch_length = min_dist * 1.0 / 2 - height_of(clade2)
    #         # Rebuild distance mat set the distances of new node at the index of min_j
    #         for k in range(0, len(dm)):
    #             if k != min_i and k != min_j:
    #                 indices_inner = [index_map[node.name] for node in inner_clade.get_terminals()]
    #                 indices_k = [index_map[node.name] for node in clades[k].get_terminals()]
    #                 pos_inner, pos_k = zip(*product(indices_inner, indices_k))
    #                 dm[min_i, k] = np.mean(original_dist_mat[list(pos_inner), list(pos_k)])
    #         dm.names[min_i] = "Inner" + str(inner_count)
    #         del dm[min_j]
    #         # Update node list
    #         clades[min_i] = inner_clade
    #         del clades[min_j]
    #     inner_clade.branch_length = 0
    #     return BaseTree.Tree(inner_clade)

    def _et_tree(self):
        """
        ET Tree

        This method reproduces the tree used by the Evolutionary Trace method in the past.This is a variant on the UPGMA
        tree construction method which joins nodes, not based on their minimum distance to each other but on the minimum
        average distance between their terminal descendants.
        """

        def height_of(clade):
            """
            Height Of

            Calculate clade height -- the longest path to any terminal (PRIVATE).

            Copied verbatim from Bio.Phylo.DistanceTreeConstructor

            Args:
                clade (Bio.Phylo.BaseTree.Clade): Clade object for which to determine the height.
            Returns:
                int: The height of the provided clade.
            """
            height = 0
            if clade.is_terminal():
                height = clade.branch_length
            else:
                height = height + max(height_of(c) for c in clade.clades)
            return height

        clades = [BaseTree.Clade(None, name) for name in self.distance_matrix.names]
        inner_count = self.size
        dm = np.tril(np.array(self.distance_matrix))
        counts = np.tril(np.ones(dm.shape, dtype=float))
        inner_clade = None
        # old
        # original_dist_mat = np.array(self.distance_matrix)
        # original_index_map = {}
        # original_clades = []
        # for i in range(self.size):
        #     original_name = self.distance_matrix.names[i]
        #     original_index_map[original_name] = i
        #     original_clade = BaseTree.Clade(None, original_name)
        #     original_clades.append(original_clade)
        # original_inner_count = self.size
        # original_dm = deepcopy(self.distance_matrix)
        # original_inner_clade = None
        # old
        while dm.shape[0] > 1:
            inner_count -= 1
            inner_name = "Inner{}".format(inner_count)
            # print(inner_name)
            min_dist = float(np.min(dm[np.tril_indices(dm.shape[0], k=-1)]))
            positions = np.where(dm == min_dist)
            # print('Positions')
            # print(positions)
            lower_triangle_pos = positions[0] > positions[1]
            # print('Lower Triangle Pos')
            # print(lower_triangle_pos)
            # print('Sub positions')
            # print(positions[0][lower_triangle_pos])
            # print(positions[1][lower_triangle_pos])
            min_mask = positions[1][lower_triangle_pos] == np.min(positions[1][lower_triangle_pos])
            min_mask2 = positions[0][lower_triangle_pos][min_mask] == np.min(positions[0][lower_triangle_pos][min_mask])
            min_j = int(positions[0][lower_triangle_pos][min_mask][min_mask2])
            min_i = int(positions[1][lower_triangle_pos][min_mask][min_mask2])
            # old
            # original_dm_array = np.array(original_dm)
            # original_min_dist = float(np.min(original_dm_array[np.triu_indices(len(original_dm), k=1)]))
            # original_positions = np.where(original_dm_array == original_min_dist)
            # original_upper_triangle_pos = original_positions[1] > original_positions[0]
            # original_min_i = int(original_positions[0][original_upper_triangle_pos][0])
            # original_min_j = int(original_positions[1][original_upper_triangle_pos][0])
            # old
            # check
            # print('MIN DIST: ', min_dist)
            # print('MIN I: ', min_i)
            # print('MIN J: ', min_j)
            # print('MIN DIST ORIGINAL: ', original_min_dist)
            # print('MIN I ORIGINAL: ', original_min_i)
            # print('MIN J ORIGINAL: ', original_min_j)
            # if (min_i != original_min_i) or (min_j != original_min_j):
            #     raise ValueError('Min value positions do not match!')
            # check
            clade1 = clades[min_i]
            clade2 = clades[min_j]
            inner_clade = BaseTree.Clade(None, inner_name)
            inner_clade.clades.append(clade1)
            inner_clade.clades.append(clade2)
            # Assign branch length
            if clade1.is_terminal():
                clade1.branch_length = min_dist * 1.0 / 2
            else:
                clade1.branch_length = min_dist * 1.0 / 2 - height_of(clade1)
            if clade2.is_terminal():
                clade2.branch_length = min_dist * 1.0 / 2
            else:
                clade2.branch_length = min_dist * 1.0 / 2 - height_of(clade2)
            # old
            # original_clade1 = original_clades[original_min_i]
            # original_clade2 = original_clades[original_min_j]
            # original_inner_count -= 1
            # original_inner_clade = BaseTree.Clade(None, "Inner{}".format(original_inner_count))
            # original_inner_clade.clades.append(original_clade1)
            # original_inner_clade.clades.append(original_clade2)
            # if original_clade1.is_terminal():
            #     original_clade1.branch_length = original_min_dist * 1.0 / 2
            # else:
            #     original_clade1.branch_length = original_min_dist * 1.0 / 2 - height_of(original_clade1)
            # if original_clade2.is_terminal():
            #     original_clade2.branch_length = original_min_dist * 1.0 / 2
            # else:
            #     original_clade2.branch_length = original_min_dist * 1.0 / 2 - height_of(original_clade2)
            # old
            # Rebuild distance mat set the distances of new node at the index of min_j
            new_dm = np.zeros((dm.shape[0] - 1, dm.shape[1] - 1))
            new_counts = np.zeros((dm.shape[0] - 1, dm.shape[1] - 1), dtype=float)
            # Define full set of indices for new lower triangle
            new_lower_triangle_ind = np.tril_indices(new_dm.shape[0], k=-1)
            # Define the indices for the top of the new lower triangle (i.e. rows above first minimum row being joined)
            top_triangle_mask = new_lower_triangle_ind[0] < min_i
            top_triangle_ind = (new_lower_triangle_ind[0][top_triangle_mask],
                                new_lower_triangle_ind[1][top_triangle_mask])
            # Fill in the values from the top of the old dm, these positions do not change since they are above the
            # minimum values being merged)
            if len(top_triangle_ind[0]) > 0:
                # print('TOP TRIANGLE')
                # print(dm[top_triangle_ind])
                new_dm[top_triangle_ind] = dm[top_triangle_ind]
                # print(counts[top_triangle_ind])
                new_counts[top_triangle_ind] = counts[top_triangle_ind]
            # Define the indices for the new row of the new lower triangle (i.e. the ones which will be filled in by
            # averaging the two minimum values rows)
            new_row_mask = new_lower_triangle_ind[0] == min_i
            new_row_ind = (new_lower_triangle_ind[0][new_row_mask], new_lower_triangle_ind[1][new_row_mask])
            # Compute the average of the two rows being merged and assign the result to the new row
            # new_counts[new_row_ind] = np.sum(counts[[min_i, min_j], :][:, 0:min_i], axis=0)
            # print(counts[min_i, 0:min_i])
            # print(counts[min_j, 0:min_i])
            # print(counts[min_i, 0:min_i] + counts[min_j, 0:min_i])
            new_counts[new_row_ind] = counts[min_i, 0:min_i] + counts[min_j, 0:min_i]
            new_row_product = dm[[min_i, min_j], :][:, 0:min_i] * counts[[min_i, min_j], :][:, 0:min_i]
            # new_dm[new_row_ind] = np.sum(new_row_product, axis=0) / new_counts[new_row_ind]
            new_dm[new_row_ind] = (new_row_product[0, :] + new_row_product[1, :]) / new_counts[new_row_ind]
            # new_dm[new_row_ind] = np.average(dm[[min_i, min_j], :][:, 0:min_i],
            #                                  weights=counts[[min_i, min_j], :][:, 0:min_i], axis=0)
            # Define the indices for the lower rectangle in the new lower triangle (i.e. positions between the minimum
            # row and column which will be filled by the averages from the merged rows/columns)
            lower_rectangle_mask = (new_lower_triangle_ind[0] > min_i) & (new_lower_triangle_ind[1] < min_i)
            lower_rectangle_ind = (new_lower_triangle_ind[0][lower_rectangle_mask],
                                   new_lower_triangle_ind[1][lower_rectangle_mask])
            # print(lower_rectangle_ind)
            # print((lower_rectangle_ind[0].shape, lower_rectangle_ind[1].shape))
            # The lower rectangle in the old dm is bounded above by min_j (not inclusive), interrupted by min_i, and
            # bounded below by the end of the matrix. On the other axis it is bounded on the left by position 0 and on
            # the right by position min_i (not inclusive)
            # print((np.r_[min_i + 1:min_j, min_j + 1:dm.shape[0]], np.r_[0:min_i]))
            # print((len(np.r_[min_i + 1:min_j, min_j + 1:dm.shape[0]]), len(np.r_[0:min_i])))
            new_dm[lower_rectangle_ind] = dm[np.r_[min_i + 1:min_j, min_j + 1:dm.shape[0]], :][:, 0:min_i].reshape(-1)
            new_counts[lower_rectangle_ind] = counts[np.r_[min_i + 1:min_j, min_j + 1:dm.shape[0]], :][:, 0:min_i].reshape(-1)
            # Define the indices for the new column of the new lower triangle (i.e. the columns which are merged from
            # the minimum values, to note, the end of the min_i row needs to be joined at the front of the min_i column)
            min_j_col_ind = (np.r_[min_i + 1:min_j, min_j + 1:dm.shape[0]], np.r_[min_i])
            min_j_col = dm[min_j_col_ind].reshape(-1, 1)
            min_j_col_counts = counts[min_j_col_ind].reshape(-1, 1)
            min_i_row_ind = (np.r_[min_j], np.r_[min_i + 1: min_j])
            min_i_row = dm[min_i_row_ind].reshape(-1, 1)
            min_i_row_counts = counts[min_i_row_ind].reshape(-1, 1)
            min_i_col_ind = (np.r_[min_j + 1: dm.shape[0]], np.r_[min_j])
            min_i_col = dm[min_i_col_ind].reshape(-1, 1)
            min_i_col_counts = counts[min_i_col_ind].reshape(-1, 1)
            min_i_col_final = np.vstack([min_i_row, min_i_col])
            min_i_col_counts_final = np.vstack([min_i_row_counts, min_i_col_counts])
            to_average = np.hstack([min_j_col, min_i_col_final])
            to_average_counts = np.hstack([min_j_col_counts, min_i_col_counts_final])
            new_col_mask = new_lower_triangle_ind[1] == min_i
            new_col_ind = (new_lower_triangle_ind[0][new_col_mask], new_lower_triangle_ind[1][new_col_mask])
            # Compute the average of the two columns being merged and assign the result to the new column
            # new_counts[new_col_ind] = np.sum(to_average_counts, axis=1)
            new_counts[new_col_ind] = to_average_counts[:, 0] + to_average_counts[:, 1]
            new_col_product = to_average * to_average_counts
            # new_dm[new_col_ind] = np.sum(new_col_product, axis=1) / new_counts[new_col_ind]
            new_dm[new_col_ind] = (new_col_product[:, 0] + new_col_product[:, 1]) / new_counts[new_col_ind]
            # new_dm[new_col_ind] = np.average(to_average, weights=to_average_counts, axis=1)
            # Define the indices for the lower triangle of the new lower triangle (i.e. the triangle outside of the new
            # column being added)
            bottom_triangle_mask = (new_lower_triangle_ind[0] > min_i) & (new_lower_triangle_ind[1] > min_i)
            bottom_triangle_ind = (new_lower_triangle_ind[0][bottom_triangle_mask],
                                   new_lower_triangle_ind[1][bottom_triangle_mask])
            # The bottom triangle in the old dm is a subset of the bottom triangle form the original  dm bounded by the
            # min_j column on the left and excluding the min_i column and row.
            old_bottom_triangle_ind = np.tril_indices(dm.shape[0], k=-1)
            old_bottom_triangle_mask = (old_bottom_triangle_ind[0] > min_i) & (old_bottom_triangle_ind[0] != min_j) & \
                                       (old_bottom_triangle_ind[1] > min_i) & (old_bottom_triangle_ind[1] != min_j)
            old_bottom_triangle_ind = (old_bottom_triangle_ind[0][old_bottom_triangle_mask],
                                       old_bottom_triangle_ind[1][old_bottom_triangle_mask])
            if len(old_bottom_triangle_ind[0]):
                new_dm[bottom_triangle_ind] = dm[old_bottom_triangle_ind[0], old_bottom_triangle_ind[1]]
                new_counts[bottom_triangle_ind] = counts[old_bottom_triangle_ind[0], old_bottom_triangle_ind[1]]
            dm = new_dm
            counts = new_counts
            # old
            # for k in range(0, len(original_dm)):
            #     if k != original_min_i and k != original_min_j:
            #         original_indices_inner = [original_index_map[node.name] for node in original_inner_clade.get_terminals()]
            #         original_indices_k = [original_index_map[node.name] for node in original_clades[k].get_terminals()]
            #         original_pos_inner, original_pos_k = zip(*product(original_indices_inner, original_indices_k))
            #         original_dm[original_min_i, k] = np.mean(original_dist_mat[list(original_pos_inner), list(original_pos_k)])
            # original_dm.names[min_i] = "Inner" + str(inner_count)
            # del original_dm[original_min_j]
            # original_clades[original_min_i] = original_inner_clade
            # del original_clades[original_min_j]
            # old
            # check
            # num_original_dm = np.tril(np.array(original_dm))
            # diff = num_original_dm - dm
            # not_passing = diff > 1E-15
            # if not_passing.any():
            # if diff.any():
            #     print('DIFFERENCES')
            #     print(original_dm.names[min_i])
            #     print('DM')
            #     print(dm)
            #     print('DM2')
            #     print(num_original_dm)
            #     print('DIFF')
            #     print(diff)
            #     indices = np.nonzero(diff)
            #     # indices = np.nonzero(not_passing)
            #     print('DM INDICES')
            #     print(dm[indices])
            #     print('DM2 INDICES')
            #     print(num_original_dm[indices])
            #     print('DIFF INDICES')
            #     print(diff[indices])
            # check
            # Update node list
            clades[min_i] = inner_clade
            del clades[min_j]
        inner_clade.branch_length = 0
        return BaseTree.Tree(inner_clade)

    def _agglomerative_clustering(self, cache_dir=None, affinity='euclidean', linkage='ward'):
        """
        Agglomerative Clustering

        Constructs a tree using agglomerative/hierarchical clustering (this requires significant conversion from the
        formatted provided by sklearn).

        Args:
            cache_dir (str): The path to the directory where the agglomerative clustering data can be saved and loaded
            from.
            affinity (str): The affinity/distance calculation method to use when operating on the distance values for
            clustering. Further details can be found at: https://scikit-learn.org/stable/modules/generated/sklearn.clust
            er.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering. The options are:
                euclidean (default)
                l1
                l2
                manhattan
                cosin
                precomputed
            linkage (str): The linkage algorithm to use when building the agglomerative clustering tree structure.
            Further details can be found at: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.Agglomera
            tiveClustering.html#sklearn.cluster.AgglomerativeClustering. The options are:
                ward (default)
                complete
                average
                single
        Returns:
            Bio.Phylo.Newick.Tree: Tree structure generated by the agglomerative/hierarchical clustering method from the
            distance matrix computed for the target alignment.
        References:
            The solution for converting an agglomerative clustering tree from sklearn into a Newick formatted tree was
            taken from the following StackOverflow discussion, the solution used was provided by user: lucianopaz
            https://stackoverflow.com/questions/29127013/plot-dendrogram-using-sklearn-agglomerativeclustering
        """
        ml_model = AgglomerativeClustering(affinity=affinity, linkage=linkage, n_clusters=len(self.distance_matrix),
                                           memory=cache_dir, compute_full_tree=True)
        ml_model.fit(np.array(self.distance_matrix))
        newick_tree_string = convert_agglomerative_clustering_to_newick_tree(
            clusterer=ml_model, labels=self.distance_matrix.names, distance_matrix=np.array(self.distance_matrix))
        if cache_dir:
            newick_fn = os.path.join(cache_dir, 'joblib', 'agg_clustering_{}_{}.newick'.format(affinity, linkage))
        else:
            newick_fn = os.path.join(os.getcwd(), 'agg_clustering_{}_{}.newick'.format(affinity, linkage))
        with open(newick_fn, 'w') as newick_handle:
            newick_handle.write(newick_tree_string)
        agg_clustering_tree = read(file=newick_fn, format='newick')
        if cache_dir is None:
            os.remove(newick_fn)
        return agg_clustering_tree

    def construct_tree(self, dm):
        """
        Construct Tree

        Construct the specified type of phylogenetic tree using the provided distance matrix.

        Args:
            dm (Bio.Phylo.TreeConstruction.DistanceMatrix): The distance matrix for an alignment of interest. If the
            tree building method is custom dm maybe be set to None. This method updates the __distance_matrix and tree
            attributes of the PhylogeneticTree instance.
        """
        method_dict = {'agglomerative': self._agglomerative_clustering, 'upgma': self._upgma_tree,
                       'custom': self._custom_tree, 'et': self._et_tree}
        if isinstance(dm, DistanceMatrix):
            self.distance_matrix = dm
        else:
            raise ValueError('Distance matrix (dm) must have type Bio.Phylo.TreeConstruction.DistanceMatrix!')
        self.size = len(dm)
        self.tree = method_dict[self.tree_method](**self.tree_args)
        self.rename_internal_nodes()

    def write_out_tree(self, filename):
        """
        Write Out Tree

        Writes the tree structure to file using the newick format.

        Args:
            filename (str): The full path to the file where the newick formatted tree should be written.
        """
        if self.tree is None:
            raise ValueError('Attempting to write tree before construction!')
        with open(filename, 'w') as tree_handle:
            write(self.tree, file=tree_handle, format='newick')

    def traverse_top_down(self):
        """
        Traverse Base Tree

        This method acts an iterator for the tree traversing from the root to the leaves always yielding the next node
        according to path length.

        Returns:
            generator: A generator which will yield a new node ordered from least to greatest path length from the root.
        """
        nodes_to_process = []
        heapq.heappush(nodes_to_process, (0, self.tree.root.name, self.tree.root))
        while len(nodes_to_process) > 0:
            curr_branch_len, curr_name, curr_node = heapq.heappop(nodes_to_process)
            yield curr_node
            for node in curr_node.clades:
                heapq.heappush(nodes_to_process, (curr_branch_len + node.branch_length, node.name, node))

    def traverse_bottom_up(self):
        """
        Traverse Base Tree

        This method acts an iterator for the tree traversing from the leaves to the root always yielding the next node
        according to path length.

        Returns:
            generator: A generator which will yield a new node ordered from greatest to least path length from the root.
        """
        nodes_to_process = []
        nodes_visited = set()
        for leaf in self.tree.root.get_terminals():
            path = self.tree.get_path(leaf)
            dist = get_path_length(path)
            nodes_visited.add(leaf.name)
            heapq.heappush(nodes_to_process, (-1 * dist, leaf.name, path, leaf))
        while len(nodes_to_process) > 0:
            curr_dist, curr_node_name, curr_path, curr_node = heapq.heappop(nodes_to_process)
            yield curr_node
            if len(curr_path) > 1:
                parent_node = curr_path[-2]
                parent_path = curr_path[:-1]
                parent_dist = curr_dist + curr_node.branch_length
                if parent_node.name not in nodes_visited:
                    nodes_visited.add(parent_node.name)
                    heapq.heappush(nodes_to_process, (parent_dist, parent_node.name, parent_path, parent_node))
            else:
                if self.tree.root.name not in nodes_visited:
                    nodes_visited.add(self.tree.root.name)
                    heapq.heappush(nodes_to_process, (0.0, self.tree.root.name, [], self.tree.root))

    def traverse_by_rank(self):
        """
        Traverse By Rank

        This method acts as an iterator for the tree, traversing from the root to the leaves always yielding a full list
        of nodes which constitute a rank (level in the tree). This means each new list generated should be larger than
        the previous list by 1 which is achieved by finding the shallowest inner node and replacing it with its two
        children. The node to replace is chosen by looking at the inner node names, the expected naming format is
        "Inner<int>" where <int> is the position of that node in the tree construction process. Nodes may be named in
        increasing order (self.tree.root.name="Inner1") or decreasing order (self.tree.root.name="Inner<self.size - 1>")

        Returns:
             generator: A generator which will yield a list of nodes corresponding to a rank/level in the tree.
        """
        root_pos = int(self.tree.root.name.strip('Inner'))
        reverse = -1 if (root_pos == (self.size - 1)) else 1
        next_node_to_split = [(reverse * root_pos, self.tree.root)]
        current_nodes = [self.tree.root]
        while len(current_nodes) < self.size:
            yield current_nodes
            pos, node_to_split = heapq.heappop(next_node_to_split)
            new_nodes = []
            for node in current_nodes:
                if node == node_to_split:
                    for child in node_to_split.clades:
                        new_nodes.append(child)
                        if not child.is_terminal():
                            heapq.heappush(next_node_to_split, (reverse * int(child.name.strip('Inner')), child))
                else:
                    new_nodes.append(node)
            current_nodes = new_nodes
        yield current_nodes

    def rename_internal_nodes(self):
        """
        Rename Internal Nodes

        This function renames all internal nodes so that trees constructed by different methods will follow the same
        internal node naming convention. The convention in this case is that every internal node has the name Inner{}
        where {} is replaced by an integer. The larger the integer the further down in the tree the node finds itself
        (i.e. the root node will have the integer 1 while the lowest will have the integer
        len(self.tree.get_terminals) - 1
        """
        starting_node_pos = int(self.tree.root.name.strip('Inner'))
        if starting_node_pos == 1:
            return
        node_pattern = 'Inner{}'
        for node in self.traverse_top_down():
            if not node.is_terminal():
                node_pos = int(node.name.strip('Inner'))
                node.name = node_pattern.format(self.size - node_pos)

    def assign_group_rank(self, ranks=None):
        """
        Assign Group Rank

        This function traverses the tree from top to bottom assigning each node to a rank and group and tracking which
        leaf/terminal nodes are related to that node.

        Args:
            ranks (set/list): If this is set to None all ranks will be evaluated (default behavior for EvolutionaryTrace
            variants). If a set or list is passed only the ranks specified there will be have ranks and groups assigned.
            The lowest possible rank is 1 and the highest possible rank is the size of the alignment used to generate
            this tree (i.e. the number of leaf nodes/sequences). A rank and group will always be assigned for rank 1,
            even if it is not specified.
        Return:
            dict: First level of the dictionary maps a rank to another dictionary. The second level of the dictionary
            maps a group value to another dictionary. This third level of the dictionary maps the key 'node' to the node
            which is the root of the group at the given rank, 'terminals' to a list of node names for the leaf/
            terminal nodes which are ancestors of the root node, and 'descendants' to a list of nodes which are
            descendants of 'node' from the closest assigned rank (at the lowest rank this will be None).
        """
        # Create a set of the ranks for which to create assignments.
        if ranks is None:
            ranks = set(range(1, 1 + self.size))
        else:
            ranks = set(ranks)
            if 1 not in ranks:
                ranks.add(1)
        # Assign nodes and terminals to rank and group labels
        rank_group_mapping = {}
        iterator = self.traverse_by_rank()
        for rank_nodes in iterator:
            rank = len(rank_nodes)
            if rank not in ranks:
                continue
            rank_group_mapping[rank] = {}
            for group in range(1, rank + 1):
                current_node = rank_nodes[group - 1]
                rank_group_mapping[rank][group] = {'node': current_node, 'terminals': []}
                if current_node.is_bifurcating():
                    rank_group_mapping[rank][group]['terminals'] += [t.name for t in current_node.get_terminals()]
                else:
                    rank_group_mapping[rank][group]['terminals'].append(current_node.name)
        # For each node assigned in the rank_group_mapping determine the descendants in the next closest rank.
        prev_rank = None
        unique_descendants = {}
        for rank in sorted(ranks, reverse=True):
            curr_rank = set([])
            for group in rank_group_mapping[rank]:
                node = rank_group_mapping[rank][group]['node']
                curr_rank.add(node)
                descendants = None
                if node.name not in unique_descendants:
                    if prev_rank is not None:
                        descendants = []
                        for prev_node in prev_rank:
                            if (node == prev_node) or node.is_parent_of(target=prev_node):
                                descendants.append(prev_node)
                        prev_rank -= set(descendants)
                    unique_descendants[node.name] = descendants
                rank_group_mapping[rank][group]['descendants'] = unique_descendants[node.name]
            prev_rank = curr_rank
        return rank_group_mapping


def get_path_length(path):
    """
    Get Parent

    Get the parent of the passed in node.

    Args:
        path (list): A list of Bio.Phylo.BaseTree.Clade objects which constitute a path between the root and a target
        node.
    Returns:
         float: The length of the path passed in.
    """
    dist = 0
    for node in path:
        dist += node.branch_length
    return dist


def get_cluster_spanner(agg_clusterer):
    """
    Get Cluster Spanner

    Get a callable that computes a given cluster's span. To compute a cluster's span, call spanner(cluster). The cluster
    must be a 2D numpy array, where the axis=0 holds separate cluster members and the axis=1 holds the different
    variables.

    Args:
        agg_clusterer (sklearn.cluster.AgglomerativeClustering): Instance of the clustering model which has already been
        fit to data and which can be used to determine the proper way to extract distances from a given distance
        matrix.
    Returns:
        function: Callable to compute a given cluster's span.
    References:
        Taken from user lucianopaz's response on stackoverflow question:
        https://stackoverflow.com/questions/29127013/plot-dendrogram-using-sklearn-agglomerativeclustering
    """
    spanner = None
    # agg_clusterer.pooling_func was deprecated in recent versions of sklearn (this code was successfully used with
    # version 0.19.0 previously. In that version agg_clusterer.pooling_func was set to np.mean by default. The new
    # behavior is less tractable to this method of conversion. To try to preserve the behavior assuming the actual tree
    # construction is still similar/the same if the deprecation is encountered, the old default function is called.
    if isinstance(agg_clusterer.pooling_func, str) and (agg_clusterer.pooling_func == 'deprecated'):
        pooling_func = np.mean
    else:
        pooling_func = agg_clusterer.pooling_func
    if agg_clusterer.linkage == 'ward':
        if agg_clusterer.affinity == 'euclidean':
            spanner = lambda x: np.sum((x - pooling_func(x, axis=0)) ** 2)
    elif agg_clusterer.linkage == 'complete':
        if agg_clusterer.affinity == 'euclidean':
            spanner = lambda x: np.max(np.sum((x[:, None, :] - x[None, :, :]) ** 2, axis=2))
        elif agg_clusterer.affinity == 'l1' or agg_clusterer.affinity == 'manhattan':
            spanner = lambda x: np.max(np.sum(np.abs(x[:, None, :] - x[None, :, :]), axis=2))
        elif agg_clusterer.affinity == 'l2':
            spanner = lambda x: np.max(np.sqrt(np.sum((x[:, None, :] - x[None, :, :]) ** 2, axis=2)))
        elif agg_clusterer.affinity == 'cosine':
            spanner = lambda x: (np.max(np.sum((x[:, None, :] * x[None, :, :])) /
                                        (np.sqrt(np.sum(x[:, None, :] * x[:, None, :], axis=2, keepdims=True)) *
                                         np.sqrt(np.sum(x[None, :, :] * x[None, :, :], axis=2, keepdims=True)))))
        else:
            raise AttributeError('Unknown affinity attribute value {0}.'.format(agg_clusterer.affinity))
    elif agg_clusterer.linkage == 'average':
        if agg_clusterer.affinity == 'euclidean':
            spanner = lambda x: np.mean(np.sum((x[:, None, :] - x[None, :, :]) ** 2, axis=2))
        elif agg_clusterer.affinity == 'l1' or agg_clusterer.affinity == 'manhattan':
            spanner = lambda x: np.mean(np.sum(np.abs(x[:, None, :] - x[None, :, :]), axis=2))
        elif agg_clusterer.affinity == 'l2':
            spanner = lambda x: np.mean(np.sqrt(np.sum((x[:, None, :] - x[None, :, :]) ** 2, axis=2)))
        elif agg_clusterer.affinity == 'cosine':
            spanner = lambda x: (np.mean(np.sum((x[:, None, :] * x[None, :, :])) /
                                         (np.sqrt(np.sum(x[:, None, :] * x[:, None, :], axis=2, keepdims=True)) *
                                          np.sqrt(np.sum(x[None, :, :] * x[None, :, :], axis=2, keepdims=True)))))
        else:
            raise AttributeError('Unknown affinity attribute value {0}.'.format(agg_clusterer.affinity))
    else:
        raise AttributeError('Unknown linkage attribute value {0}.'.format(agg_clusterer.linkage))
    return spanner


def go_down_tree(children, n_leaves, x, leaf_labels, nodename, spanner, inner):
    """
    go_down_tree(children,n_leaves,X,leaf_labels,nodename,spanner)

    Iterative function that traverses the subtree that descends from
    nodename and returns the Newick representation of the subtree.

    Args:
        children (list): sklearn.cluster.AgglomerativeClustering.children_
        n_leaves (int): sklearn.cluster.AgglomerativeClustering.n_leaves_
        x (2D np.array): Parameters supplied to sklearn.cluster.AgglomerativeClustering.fit
        leaf_labels (list): The label for each parameter in array axis=0 of x.
        nodename (int): The intermediate node name whose children are located in children[nodename-n_leaves].
        spanner (function): Callable that computes the dendrite's span
        inner (list): A list of labels for inner nodes which is used every time an internal node needs to be named.
    Returns:
        str: The str representation of the agglomerative clutering tree in Newick format.
    References:
        Taken from user lucianopaz's response on stackoverflow question:
        https://stackoverflow.com/questions/29127013/plot-dendrogram-using-sklearn-agglomerativeclustering
    """
    nodeindex = nodename-n_leaves
    if nodename < n_leaves:
        return leaf_labels[nodeindex], np.array([x[nodeindex]])
    else:
        node_children = children[nodeindex]
        branch1, branch1samples = go_down_tree(children, n_leaves, x, leaf_labels, node_children[1], spanner, inner)
        if branch1.endswith(')'):
            branch1 += 'Inner{}'.format(inner.pop())
        branch0, branch0samples = go_down_tree(children, n_leaves, x, leaf_labels, node_children[0], spanner, inner)
        if branch0.endswith(')'):
            branch0 += 'Inner{}'.format(inner.pop())
        node = np.vstack((branch0samples, branch1samples))
        branch0span = spanner(branch0samples)
        branch1span = spanner(branch1samples)
        nodespan = spanner(node)
        branch0distance = nodespan-branch0span
        branch1distance = nodespan-branch1span
        nodename = '({branch0}:{branch0distance},{branch1}:{branch1distance})'.format(
            branch0=branch0, branch0distance=branch0distance, branch1=branch1, branch1distance=branch1distance)
        return nodename, node


def build_newick_tree(children, n_leaves, x, leaf_labels, spanner):
    """
    Build Newick Tree

    Generate a string representation (Newick tree) from the sklearn.cluster.AgglomerativeClustering.fit output.

    Args:
        children (list): sklearn.cluster.AgglomerativeClustering.children_
        n_leaves (int): sklearn.cluster.AgglomerativeClustering.n_leaves_
        x (2D np.array): Parameters supplied to sklearn.cluster.AgglomerativeClustering.fit
        leaf_labels (list): The label for each parameter in array axis=0 of x.
        spanner (function): Callable that computes the dendrite's span
    Returns:
        str: The final string with the Newick representation of the agglomerative clustering tree being converted.
    References:
        Taken from user lucianopaz's response on stackoverflow question:
        https://stackoverflow.com/questions/29127013/plot-dendrogram-using-sklearn-agglomerativeclustering
    """
    inner_labels = list(range(1, n_leaves))
    inner_string, inner_node = go_down_tree(children, n_leaves, x, leaf_labels, len(children)+n_leaves-1, spanner,
                                            inner_labels)
    prepend_to_root = inner_string + 'Inner{};'.format(inner_labels.pop())
    return prepend_to_root


def convert_agglomerative_clustering_to_newick_tree(clusterer, labels, distance_matrix):
    """
    Convert Agglomerative Clustering To Newick Tree

    This function converts the tree generated by sklearn.cluster.AgglomerativeClustering.fit() to a Newick formatted
    string.

    Args:
        clusterer (sklearn.cluster.AgglomerativeClustering): Instance of the clustering model which has already been
        fit to data and which can be used to determine the proper way to extract distances from a given distance
        matrix.
        labels (list): The label for each parameter in array axis=0 of distance_matrix.
        distance_matrix (2D np.array): Parameters supplied to sklearn.cluster.AgglomerativeClustering.fit
    Returns:
        str: The final string with the Newick representation of the agglomerative clustering tree being converted.
    References:
        Adapted from user lucianopaz's response on stackoverflow question:
        https://stackoverflow.com/questions/29127013/plot-dendrogram-using-sklearn-agglomerativeclustering
    """
    spanner = get_cluster_spanner(clusterer)
    newick_tree = build_newick_tree(clusterer.children_, clusterer.n_leaves_, distance_matrix, labels, spanner)
    return newick_tree
